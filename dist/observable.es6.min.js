/*! js-observables ES6 v0.1.1 */


!function(e,t){if("function"==typeof define&&define.amd)define([],t);else if("object"==typeof exports)module.exports=t();else{var r=t();e.JsObserver=r.Observer,e.JsObservable=r.Observable,e.JsSubscription=r.Subscription}}(this,function(){function e(){if("undefined"!=typeof window&&window.console)return window.console;if("undefined"!=typeof self&&self.console)return self.console;if(this.console)return this.console;if("undefined"!=typeof console)return console;let e={};return e.error=e.warn=e.log=(()=>{}),e}class t{constructor(t,r,s){if(!(t instanceof Function))throw"Invalid arguments. The 'next' function cannot be null.";!r||r instanceof Function||(e.error("Invalid error function provided to Observer creation",this,r),r=void 0),!s||s instanceof Function||(e.error("Invalid complete function provided to Observer creation",this,ercompleteror),s=void 0),this[Symbol.for("Observer.next")]=t,this[Symbol.for("Observer.error")]=r,this[Symbol.for("Observer.complete")]=s,this._isComplete=!1,this.start=this.start.bind(this),this.next=this.next.bind(this),this.error=this.error.bind(this),this.complete=this.complete.bind(this)}get closed(){return!!this[Symbol.for("Observer.subscription")]&&this[Symbol.for("Observer.subscription")].closed||this._isComplete}start(t){if(this[Symbol.for("Observer.subscription")]&&!this[Symbol.for("Observer.subscription")].closed)throw e().error("Invalid state. Observer is already subscribed",this,this[Symbol.for("Observer.subscription")],t),"Invalid state. Observer is already subscribed";t instanceof s&&!t.closed?(this[Symbol.for("Observer.subscription")]=t,this._isComplete=!1):e().error("Invalid subscription.",this,t)}next(e){if(!this.closed)return this[Symbol.for("Observer.next")].call(this,e)}error(e){let t=this[Symbol.for("Observer.error")];if(!this.closed&&t instanceof Function)return t.call(this,e)}complete(){if(this.closed)return;let e=this[Symbol.for("Observer.complete")];if(e instanceof Function)var t=e.call(this);let r=Symbol.for("Observer.subscription");return this[r]&&this[r].unsubscribe(),this[r]=null,this._isComplete=!0,t}static to(e,r,s){return new t(e,r,s)}static[Symbol.hasInstance](e){return!!e&&e.next instanceof Function}}class r{constructor(t){t instanceof Function?this[Symbol.for("Observable.subscriber")]=t:(e().warn("No Subscription Function was passed into the Observable. Therefore this Observable will do nothing.",this,t),this[Symbol.for("Observable.subscriber")]=function(){})}subscribe(r,i,o){if(!r)return e().error("Observer subscription attempted, but the arguments are empty",this,r);if(r instanceof Function&&(r=new t(r,i,o)),!(r instanceof t))return e().error("Observer subscription attempted, but the argument was not an Observer.",this,r);let n=r,c=this[Symbol.for("Observable.subscriber")](n),b=c instanceof s?c:new s(c);return n.start instanceof Function&&n.start(b),b}static of(e,...t){0==t.length&&void 0!==e[Symbol.iterator]||(e=t.unshift(e)&&t);var s=e[Symbol.iterator]();return new(this.prototype instanceof r?this:r)(e=>{for(let t of s)e.next(t);e.complete instanceof Function&&e.complete()})}static from(t){return t instanceof r?new r(e=>t.subscribe(e)):t&&void 0!==t[Symbol.iterator]?r.of(t):void e().error("Type error. Incorrect argument type. Arguement must be an Observable or Iterable.",t)}static[Symbol.hasInstance](e){return!!e&&e.subscribe instanceof Function}}class s extends Function{constructor(e){e instanceof Function||(e=null),s.map=s.map||new WeakMap,s.keys=s.keys||{size:0};let t="_"+s.keys.size;super("return Subscription.map.get(Subscription.keys['"+t+"']).unsubscribe();"),s.map.set(s.keys[t]={},this),s.keys.size++,this[Symbol.for("Subscription.id")]=t,this[Symbol.for("Subscription.cleanup")]=e,this[Symbol.for("Subscription.closed")]=!1}unsubscribe(){if(this.closed)return;this[Symbol.for("Subscription.closed")]=!0;let e=this[Symbol.for("Subscription.cleanup")]&&this[Symbol.for("Subscription.cleanup")]();return s.map.delete(s.keys[this[Symbol.for("Subscription.id")]]),s.keys[this[Symbol.for("Subscription.id")]]=this[Symbol.for("Subscription.cleanup")]=null,e}get closed(){return this[Symbol.for("Subscription.closed")]}static close(e){if(s.keys[e]){let t=s.map.get(s.keys[e]);t&&t.unsubscribe()}}static[Symbol.hasInstance](e){return!!e&&e.unsubscribe instanceof Function}}return{Observer:t,Observable:r,Subscription:s}});